{"ast":null,"code":"/*!\n * jQuery UI Position 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n\n(function (factory) {\n  \"use strict\";\n\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([\"jquery\", \"./version\"], factory);\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n})(function ($) {\n  \"use strict\";\n\n  (function () {\n    var cachedScrollbarWidth,\n      max = Math.max,\n      abs = Math.abs,\n      rhorizontal = /left|center|right/,\n      rvertical = /top|center|bottom/,\n      roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n      rposition = /^\\w+/,\n      rpercent = /%$/,\n      _position = $.fn.position;\n    function getOffsets(offsets, width, height) {\n      return [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)];\n    }\n    function parseCss(element, property) {\n      return parseInt($.css(element, property), 10) || 0;\n    }\n    function isWindow(obj) {\n      return obj != null && obj === obj.window;\n    }\n    function getDimensions(elem) {\n      var raw = elem[0];\n      if (raw.nodeType === 9) {\n        return {\n          width: elem.width(),\n          height: elem.height(),\n          offset: {\n            top: 0,\n            left: 0\n          }\n        };\n      }\n      if (isWindow(raw)) {\n        return {\n          width: elem.width(),\n          height: elem.height(),\n          offset: {\n            top: elem.scrollTop(),\n            left: elem.scrollLeft()\n          }\n        };\n      }\n      if (raw.preventDefault) {\n        return {\n          width: 0,\n          height: 0,\n          offset: {\n            top: raw.pageY,\n            left: raw.pageX\n          }\n        };\n      }\n      return {\n        width: elem.outerWidth(),\n        height: elem.outerHeight(),\n        offset: elem.offset()\n      };\n    }\n    $.position = {\n      scrollbarWidth: function () {\n        if (cachedScrollbarWidth !== undefined) {\n          return cachedScrollbarWidth;\n        }\n        var w1,\n          w2,\n          div = $(\"<div style=\" + \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" + \"<div style='height:300px;width:auto;'></div></div>\"),\n          innerDiv = div.children()[0];\n        $(\"body\").append(div);\n        w1 = innerDiv.offsetWidth;\n        div.css(\"overflow\", \"scroll\");\n        w2 = innerDiv.offsetWidth;\n        if (w1 === w2) {\n          w2 = div[0].clientWidth;\n        }\n        div.remove();\n        return cachedScrollbarWidth = w1 - w2;\n      },\n      getScrollInfo: function (within) {\n        var overflowX = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-x\"),\n          overflowY = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-y\"),\n          hasOverflowX = overflowX === \"scroll\" || overflowX === \"auto\" && within.width < within.element[0].scrollWidth,\n          hasOverflowY = overflowY === \"scroll\" || overflowY === \"auto\" && within.height < within.element[0].scrollHeight;\n        return {\n          width: hasOverflowY ? $.position.scrollbarWidth() : 0,\n          height: hasOverflowX ? $.position.scrollbarWidth() : 0\n        };\n      },\n      getWithinInfo: function (element) {\n        var withinElement = $(element || window),\n          isElemWindow = isWindow(withinElement[0]),\n          isDocument = !!withinElement[0] && withinElement[0].nodeType === 9,\n          hasOffset = !isElemWindow && !isDocument;\n        return {\n          element: withinElement,\n          isWindow: isElemWindow,\n          isDocument: isDocument,\n          offset: hasOffset ? $(element).offset() : {\n            left: 0,\n            top: 0\n          },\n          scrollLeft: withinElement.scrollLeft(),\n          scrollTop: withinElement.scrollTop(),\n          width: withinElement.outerWidth(),\n          height: withinElement.outerHeight()\n        };\n      }\n    };\n    $.fn.position = function (options) {\n      if (!options || !options.of) {\n        return _position.apply(this, arguments);\n      }\n\n      // Make a copy, we don't want to modify arguments\n      options = $.extend({}, options);\n      var atOffset,\n        targetWidth,\n        targetHeight,\n        targetOffset,\n        basePosition,\n        dimensions,\n        // Make sure string options are treated as CSS selectors\n        target = typeof options.of === \"string\" ? $(document).find(options.of) : $(options.of),\n        within = $.position.getWithinInfo(options.within),\n        scrollInfo = $.position.getScrollInfo(within),\n        collision = (options.collision || \"flip\").split(\" \"),\n        offsets = {};\n      dimensions = getDimensions(target);\n      if (target[0].preventDefault) {\n        // Force left top to allow flipping\n        options.at = \"left top\";\n      }\n      targetWidth = dimensions.width;\n      targetHeight = dimensions.height;\n      targetOffset = dimensions.offset;\n\n      // Clone to reuse original targetOffset later\n      basePosition = $.extend({}, targetOffset);\n\n      // Force my and at to have valid horizontal and vertical positions\n      // if a value is missing or invalid, it will be converted to center\n      $.each([\"my\", \"at\"], function () {\n        var pos = (options[this] || \"\").split(\" \"),\n          horizontalOffset,\n          verticalOffset;\n        if (pos.length === 1) {\n          pos = rhorizontal.test(pos[0]) ? pos.concat([\"center\"]) : rvertical.test(pos[0]) ? [\"center\"].concat(pos) : [\"center\", \"center\"];\n        }\n        pos[0] = rhorizontal.test(pos[0]) ? pos[0] : \"center\";\n        pos[1] = rvertical.test(pos[1]) ? pos[1] : \"center\";\n\n        // Calculate offsets\n        horizontalOffset = roffset.exec(pos[0]);\n        verticalOffset = roffset.exec(pos[1]);\n        offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0];\n\n        // Reduce to just the positions without the offsets\n        options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];\n      });\n\n      // Normalize collision option\n      if (collision.length === 1) {\n        collision[1] = collision[0];\n      }\n      if (options.at[0] === \"right\") {\n        basePosition.left += targetWidth;\n      } else if (options.at[0] === \"center\") {\n        basePosition.left += targetWidth / 2;\n      }\n      if (options.at[1] === \"bottom\") {\n        basePosition.top += targetHeight;\n      } else if (options.at[1] === \"center\") {\n        basePosition.top += targetHeight / 2;\n      }\n      atOffset = getOffsets(offsets.at, targetWidth, targetHeight);\n      basePosition.left += atOffset[0];\n      basePosition.top += atOffset[1];\n      return this.each(function () {\n        var collisionPosition,\n          using,\n          elem = $(this),\n          elemWidth = elem.outerWidth(),\n          elemHeight = elem.outerHeight(),\n          marginLeft = parseCss(this, \"marginLeft\"),\n          marginTop = parseCss(this, \"marginTop\"),\n          collisionWidth = elemWidth + marginLeft + parseCss(this, \"marginRight\") + scrollInfo.width,\n          collisionHeight = elemHeight + marginTop + parseCss(this, \"marginBottom\") + scrollInfo.height,\n          position = $.extend({}, basePosition),\n          myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());\n        if (options.my[0] === \"right\") {\n          position.left -= elemWidth;\n        } else if (options.my[0] === \"center\") {\n          position.left -= elemWidth / 2;\n        }\n        if (options.my[1] === \"bottom\") {\n          position.top -= elemHeight;\n        } else if (options.my[1] === \"center\") {\n          position.top -= elemHeight / 2;\n        }\n        position.left += myOffset[0];\n        position.top += myOffset[1];\n        collisionPosition = {\n          marginLeft: marginLeft,\n          marginTop: marginTop\n        };\n        $.each([\"left\", \"top\"], function (i, dir) {\n          if ($.ui.position[collision[i]]) {\n            $.ui.position[collision[i]][dir](position, {\n              targetWidth: targetWidth,\n              targetHeight: targetHeight,\n              elemWidth: elemWidth,\n              elemHeight: elemHeight,\n              collisionPosition: collisionPosition,\n              collisionWidth: collisionWidth,\n              collisionHeight: collisionHeight,\n              offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],\n              my: options.my,\n              at: options.at,\n              within: within,\n              elem: elem\n            });\n          }\n        });\n        if (options.using) {\n          // Adds feedback as second argument to using callback, if present\n          using = function (props) {\n            var left = targetOffset.left - position.left,\n              right = left + targetWidth - elemWidth,\n              top = targetOffset.top - position.top,\n              bottom = top + targetHeight - elemHeight,\n              feedback = {\n                target: {\n                  element: target,\n                  left: targetOffset.left,\n                  top: targetOffset.top,\n                  width: targetWidth,\n                  height: targetHeight\n                },\n                element: {\n                  element: elem,\n                  left: position.left,\n                  top: position.top,\n                  width: elemWidth,\n                  height: elemHeight\n                },\n                horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n                vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n              };\n            if (targetWidth < elemWidth && abs(left + right) < targetWidth) {\n              feedback.horizontal = \"center\";\n            }\n            if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {\n              feedback.vertical = \"middle\";\n            }\n            if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {\n              feedback.important = \"horizontal\";\n            } else {\n              feedback.important = \"vertical\";\n            }\n            options.using.call(this, props, feedback);\n          };\n        }\n        elem.offset($.extend(position, {\n          using: using\n        }));\n      });\n    };\n    $.ui.position = {\n      fit: {\n        left: function (position, data) {\n          var within = data.within,\n            withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n            outerWidth = within.width,\n            collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n            overLeft = withinOffset - collisionPosLeft,\n            overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n            newOverRight;\n\n          // Element is wider than within\n          if (data.collisionWidth > outerWidth) {\n            // Element is initially over the left side of within\n            if (overLeft > 0 && overRight <= 0) {\n              newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n              position.left += overLeft - newOverRight;\n\n              // Element is initially over right side of within\n            } else if (overRight > 0 && overLeft <= 0) {\n              position.left = withinOffset;\n\n              // Element is initially over both left and right sides of within\n            } else {\n              if (overLeft > overRight) {\n                position.left = withinOffset + outerWidth - data.collisionWidth;\n              } else {\n                position.left = withinOffset;\n              }\n            }\n\n            // Too far left -> align with left edge\n          } else if (overLeft > 0) {\n            position.left += overLeft;\n\n            // Too far right -> align with right edge\n          } else if (overRight > 0) {\n            position.left -= overRight;\n\n            // Adjust based on position and margin\n          } else {\n            position.left = max(position.left - collisionPosLeft, position.left);\n          }\n        },\n        top: function (position, data) {\n          var within = data.within,\n            withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n            outerHeight = data.within.height,\n            collisionPosTop = position.top - data.collisionPosition.marginTop,\n            overTop = withinOffset - collisionPosTop,\n            overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n            newOverBottom;\n\n          // Element is taller than within\n          if (data.collisionHeight > outerHeight) {\n            // Element is initially over the top of within\n            if (overTop > 0 && overBottom <= 0) {\n              newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n              position.top += overTop - newOverBottom;\n\n              // Element is initially over bottom of within\n            } else if (overBottom > 0 && overTop <= 0) {\n              position.top = withinOffset;\n\n              // Element is initially over both top and bottom of within\n            } else {\n              if (overTop > overBottom) {\n                position.top = withinOffset + outerHeight - data.collisionHeight;\n              } else {\n                position.top = withinOffset;\n              }\n            }\n\n            // Too far up -> align with top\n          } else if (overTop > 0) {\n            position.top += overTop;\n\n            // Too far down -> align with bottom edge\n          } else if (overBottom > 0) {\n            position.top -= overBottom;\n\n            // Adjust based on position and margin\n          } else {\n            position.top = max(position.top - collisionPosTop, position.top);\n          }\n        }\n      },\n      flip: {\n        left: function (position, data) {\n          var within = data.within,\n            withinOffset = within.offset.left + within.scrollLeft,\n            outerWidth = within.width,\n            offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n            collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n            overLeft = collisionPosLeft - offsetLeft,\n            overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n            myOffset = data.my[0] === \"left\" ? -data.elemWidth : data.my[0] === \"right\" ? data.elemWidth : 0,\n            atOffset = data.at[0] === \"left\" ? data.targetWidth : data.at[0] === \"right\" ? -data.targetWidth : 0,\n            offset = -2 * data.offset[0],\n            newOverRight,\n            newOverLeft;\n          if (overLeft < 0) {\n            newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n            if (newOverRight < 0 || newOverRight < abs(overLeft)) {\n              position.left += myOffset + atOffset + offset;\n            }\n          } else if (overRight > 0) {\n            newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n            if (newOverLeft > 0 || abs(newOverLeft) < overRight) {\n              position.left += myOffset + atOffset + offset;\n            }\n          }\n        },\n        top: function (position, data) {\n          var within = data.within,\n            withinOffset = within.offset.top + within.scrollTop,\n            outerHeight = within.height,\n            offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n            collisionPosTop = position.top - data.collisionPosition.marginTop,\n            overTop = collisionPosTop - offsetTop,\n            overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n            top = data.my[1] === \"top\",\n            myOffset = top ? -data.elemHeight : data.my[1] === \"bottom\" ? data.elemHeight : 0,\n            atOffset = data.at[1] === \"top\" ? data.targetHeight : data.at[1] === \"bottom\" ? -data.targetHeight : 0,\n            offset = -2 * data.offset[1],\n            newOverTop,\n            newOverBottom;\n          if (overTop < 0) {\n            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n            if (newOverBottom < 0 || newOverBottom < abs(overTop)) {\n              position.top += myOffset + atOffset + offset;\n            }\n          } else if (overBottom > 0) {\n            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n            if (newOverTop > 0 || abs(newOverTop) < overBottom) {\n              position.top += myOffset + atOffset + offset;\n            }\n          }\n        }\n      },\n      flipfit: {\n        left: function () {\n          $.ui.position.flip.left.apply(this, arguments);\n          $.ui.position.fit.left.apply(this, arguments);\n        },\n        top: function () {\n          $.ui.position.flip.top.apply(this, arguments);\n          $.ui.position.fit.top.apply(this, arguments);\n        }\n      }\n    };\n  })();\n  return $.ui.position;\n});","map":{"version":3,"names":["factory","define","amd","jQuery","$","cachedScrollbarWidth","max","Math","abs","rhorizontal","rvertical","roffset","rposition","rpercent","_position","fn","position","getOffsets","offsets","width","height","parseFloat","test","parseCss","element","property","parseInt","css","isWindow","obj","window","getDimensions","elem","raw","nodeType","offset","top","left","scrollTop","scrollLeft","preventDefault","pageY","pageX","outerWidth","outerHeight","scrollbarWidth","undefined","w1","w2","div","innerDiv","children","append","offsetWidth","clientWidth","remove","getScrollInfo","within","overflowX","isDocument","overflowY","hasOverflowX","scrollWidth","hasOverflowY","scrollHeight","getWithinInfo","withinElement","isElemWindow","hasOffset","options","of","apply","arguments","extend","atOffset","targetWidth","targetHeight","targetOffset","basePosition","dimensions","target","document","find","scrollInfo","collision","split","at","each","pos","horizontalOffset","verticalOffset","length","concat","exec","collisionPosition","using","elemWidth","elemHeight","marginLeft","marginTop","collisionWidth","collisionHeight","myOffset","my","i","dir","ui","props","right","bottom","feedback","horizontal","vertical","important","call","fit","data","withinOffset","collisionPosLeft","overLeft","overRight","newOverRight","collisionPosTop","overTop","overBottom","newOverBottom","flip","offsetLeft","newOverLeft","offsetTop","newOverTop","flipfit"],"sources":["C:/Users/reshav/Desktop/Makonis/my-app/node_modules/jquery-ui/ui/position.js"],"sourcesContent":["/*!\n * jQuery UI Position 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n\n( function( factory ) {\n\t\"use strict\";\n\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine( [ \"jquery\", \"./version\" ], factory );\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n} )( function( $ ) {\n\"use strict\";\n\n( function() {\nvar cachedScrollbarWidth,\n\tmax = Math.max,\n\tabs = Math.abs,\n\trhorizontal = /left|center|right/,\n\trvertical = /top|center|bottom/,\n\troffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\trposition = /^\\w+/,\n\trpercent = /%$/,\n\t_position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n\treturn [\n\t\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n\t\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n\t];\n}\n\nfunction parseCss( element, property ) {\n\treturn parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction isWindow( obj ) {\n\treturn obj != null && obj === obj.window;\n}\n\nfunction getDimensions( elem ) {\n\tvar raw = elem[ 0 ];\n\tif ( raw.nodeType === 9 ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: 0, left: 0 }\n\t\t};\n\t}\n\tif ( isWindow( raw ) ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t};\n\t}\n\tif ( raw.preventDefault ) {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t};\n\t}\n\treturn {\n\t\twidth: elem.outerWidth(),\n\t\theight: elem.outerHeight(),\n\t\toffset: elem.offset()\n\t};\n}\n\n$.position = {\n\tscrollbarWidth: function() {\n\t\tif ( cachedScrollbarWidth !== undefined ) {\n\t\t\treturn cachedScrollbarWidth;\n\t\t}\n\t\tvar w1, w2,\n\t\t\tdiv = $( \"<div style=\" +\n\t\t\t\t\"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\n\t\t\t\t\"<div style='height:300px;width:auto;'></div></div>\" ),\n\t\t\tinnerDiv = div.children()[ 0 ];\n\n\t\t$( \"body\" ).append( div );\n\t\tw1 = innerDiv.offsetWidth;\n\t\tdiv.css( \"overflow\", \"scroll\" );\n\n\t\tw2 = innerDiv.offsetWidth;\n\n\t\tif ( w1 === w2 ) {\n\t\t\tw2 = div[ 0 ].clientWidth;\n\t\t}\n\n\t\tdiv.remove();\n\n\t\treturn ( cachedScrollbarWidth = w1 - w2 );\n\t},\n\tgetScrollInfo: function( within ) {\n\t\tvar overflowX = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-x\" ),\n\t\t\toverflowY = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-y\" ),\n\t\t\thasOverflowX = overflowX === \"scroll\" ||\n\t\t\t\t( overflowX === \"auto\" && within.width < within.element[ 0 ].scrollWidth ),\n\t\t\thasOverflowY = overflowY === \"scroll\" ||\n\t\t\t\t( overflowY === \"auto\" && within.height < within.element[ 0 ].scrollHeight );\n\t\treturn {\n\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t};\n\t},\n\tgetWithinInfo: function( element ) {\n\t\tvar withinElement = $( element || window ),\n\t\t\tisElemWindow = isWindow( withinElement[ 0 ] ),\n\t\t\tisDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,\n\t\t\thasOffset = !isElemWindow && !isDocument;\n\t\treturn {\n\t\t\telement: withinElement,\n\t\t\tisWindow: isElemWindow,\n\t\t\tisDocument: isDocument,\n\t\t\toffset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },\n\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\tscrollTop: withinElement.scrollTop(),\n\t\t\twidth: withinElement.outerWidth(),\n\t\t\theight: withinElement.outerHeight()\n\t\t};\n\t}\n};\n\n$.fn.position = function( options ) {\n\tif ( !options || !options.of ) {\n\t\treturn _position.apply( this, arguments );\n\t}\n\n\t// Make a copy, we don't want to modify arguments\n\toptions = $.extend( {}, options );\n\n\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n\n\t\t// Make sure string options are treated as CSS selectors\n\t\ttarget = typeof options.of === \"string\" ?\n\t\t\t$( document ).find( options.of ) :\n\t\t\t$( options.of ),\n\n\t\twithin = $.position.getWithinInfo( options.within ),\n\t\tscrollInfo = $.position.getScrollInfo( within ),\n\t\tcollision = ( options.collision || \"flip\" ).split( \" \" ),\n\t\toffsets = {};\n\n\tdimensions = getDimensions( target );\n\tif ( target[ 0 ].preventDefault ) {\n\n\t\t// Force left top to allow flipping\n\t\toptions.at = \"left top\";\n\t}\n\ttargetWidth = dimensions.width;\n\ttargetHeight = dimensions.height;\n\ttargetOffset = dimensions.offset;\n\n\t// Clone to reuse original targetOffset later\n\tbasePosition = $.extend( {}, targetOffset );\n\n\t// Force my and at to have valid horizontal and vertical positions\n\t// if a value is missing or invalid, it will be converted to center\n\t$.each( [ \"my\", \"at\" ], function() {\n\t\tvar pos = ( options[ this ] || \"\" ).split( \" \" ),\n\t\t\thorizontalOffset,\n\t\t\tverticalOffset;\n\n\t\tif ( pos.length === 1 ) {\n\t\t\tpos = rhorizontal.test( pos[ 0 ] ) ?\n\t\t\t\tpos.concat( [ \"center\" ] ) :\n\t\t\t\trvertical.test( pos[ 0 ] ) ?\n\t\t\t\t\t[ \"center\" ].concat( pos ) :\n\t\t\t\t\t[ \"center\", \"center\" ];\n\t\t}\n\t\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n\t\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n\t\t// Calculate offsets\n\t\thorizontalOffset = roffset.exec( pos[ 0 ] );\n\t\tverticalOffset = roffset.exec( pos[ 1 ] );\n\t\toffsets[ this ] = [\n\t\t\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\n\t\t\tverticalOffset ? verticalOffset[ 0 ] : 0\n\t\t];\n\n\t\t// Reduce to just the positions without the offsets\n\t\toptions[ this ] = [\n\t\t\trposition.exec( pos[ 0 ] )[ 0 ],\n\t\t\trposition.exec( pos[ 1 ] )[ 0 ]\n\t\t];\n\t} );\n\n\t// Normalize collision option\n\tif ( collision.length === 1 ) {\n\t\tcollision[ 1 ] = collision[ 0 ];\n\t}\n\n\tif ( options.at[ 0 ] === \"right\" ) {\n\t\tbasePosition.left += targetWidth;\n\t} else if ( options.at[ 0 ] === \"center\" ) {\n\t\tbasePosition.left += targetWidth / 2;\n\t}\n\n\tif ( options.at[ 1 ] === \"bottom\" ) {\n\t\tbasePosition.top += targetHeight;\n\t} else if ( options.at[ 1 ] === \"center\" ) {\n\t\tbasePosition.top += targetHeight / 2;\n\t}\n\n\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n\tbasePosition.left += atOffset[ 0 ];\n\tbasePosition.top += atOffset[ 1 ];\n\n\treturn this.each( function() {\n\t\tvar collisionPosition, using,\n\t\t\telem = $( this ),\n\t\t\telemWidth = elem.outerWidth(),\n\t\t\telemHeight = elem.outerHeight(),\n\t\t\tmarginLeft = parseCss( this, \"marginLeft\" ),\n\t\t\tmarginTop = parseCss( this, \"marginTop\" ),\n\t\t\tcollisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) +\n\t\t\t\tscrollInfo.width,\n\t\t\tcollisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) +\n\t\t\t\tscrollInfo.height,\n\t\t\tposition = $.extend( {}, basePosition ),\n\t\t\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n\t\tif ( options.my[ 0 ] === \"right\" ) {\n\t\t\tposition.left -= elemWidth;\n\t\t} else if ( options.my[ 0 ] === \"center\" ) {\n\t\t\tposition.left -= elemWidth / 2;\n\t\t}\n\n\t\tif ( options.my[ 1 ] === \"bottom\" ) {\n\t\t\tposition.top -= elemHeight;\n\t\t} else if ( options.my[ 1 ] === \"center\" ) {\n\t\t\tposition.top -= elemHeight / 2;\n\t\t}\n\n\t\tposition.left += myOffset[ 0 ];\n\t\tposition.top += myOffset[ 1 ];\n\n\t\tcollisionPosition = {\n\t\t\tmarginLeft: marginLeft,\n\t\t\tmarginTop: marginTop\n\t\t};\n\n\t\t$.each( [ \"left\", \"top\" ], function( i, dir ) {\n\t\t\tif ( $.ui.position[ collision[ i ] ] ) {\n\t\t\t\t$.ui.position[ collision[ i ] ][ dir ]( position, {\n\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n\t\t\t\t\tmy: options.my,\n\t\t\t\t\tat: options.at,\n\t\t\t\t\twithin: within,\n\t\t\t\t\telem: elem\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tif ( options.using ) {\n\n\t\t\t// Adds feedback as second argument to using callback, if present\n\t\t\tusing = function( props ) {\n\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\tright = left + targetWidth - elemWidth,\n\t\t\t\t\ttop = targetOffset.top - position.top,\n\t\t\t\t\tbottom = top + targetHeight - elemHeight,\n\t\t\t\t\tfeedback = {\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\thorizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n\t\t\t\t\t\tvertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n\t\t\t\t\t};\n\t\t\t\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n\t\t\t\t\tfeedback.horizontal = \"center\";\n\t\t\t\t}\n\t\t\t\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n\t\t\t\t\tfeedback.vertical = \"middle\";\n\t\t\t\t}\n\t\t\t\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n\t\t\t\t\tfeedback.important = \"horizontal\";\n\t\t\t\t} else {\n\t\t\t\t\tfeedback.important = \"vertical\";\n\t\t\t\t}\n\t\t\t\toptions.using.call( this, props, feedback );\n\t\t\t};\n\t\t}\n\n\t\telem.offset( $.extend( position, { using: using } ) );\n\t} );\n};\n\n$.ui.position = {\n\tfit: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\touterWidth = within.width,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = withinOffset - collisionPosLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\tnewOverRight;\n\n\t\t\t// Element is wider than within\n\t\t\tif ( data.collisionWidth > outerWidth ) {\n\n\t\t\t\t// Element is initially over the left side of within\n\t\t\t\tif ( overLeft > 0 && overRight <= 0 ) {\n\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.left += overLeft - newOverRight;\n\n\t\t\t\t// Element is initially over right side of within\n\t\t\t\t} else if ( overRight > 0 && overLeft <= 0 ) {\n\t\t\t\t\tposition.left = withinOffset;\n\n\t\t\t\t// Element is initially over both left and right sides of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overLeft > overRight ) {\n\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far left -> align with left edge\n\t\t\t} else if ( overLeft > 0 ) {\n\t\t\t\tposition.left += overLeft;\n\n\t\t\t// Too far right -> align with right edge\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tposition.left -= overRight;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.left = max( position.left - collisionPosLeft, position.left );\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\touterHeight = data.within.height,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = withinOffset - collisionPosTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\tnewOverBottom;\n\n\t\t\t// Element is taller than within\n\t\t\tif ( data.collisionHeight > outerHeight ) {\n\n\t\t\t\t// Element is initially over the top of within\n\t\t\t\tif ( overTop > 0 && overBottom <= 0 ) {\n\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.top += overTop - newOverBottom;\n\n\t\t\t\t// Element is initially over bottom of within\n\t\t\t\t} else if ( overBottom > 0 && overTop <= 0 ) {\n\t\t\t\t\tposition.top = withinOffset;\n\n\t\t\t\t// Element is initially over both top and bottom of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overTop > overBottom ) {\n\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far up -> align with top\n\t\t\t} else if ( overTop > 0 ) {\n\t\t\t\tposition.top += overTop;\n\n\t\t\t// Too far down -> align with bottom edge\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tposition.top -= overBottom;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.top = max( position.top - collisionPosTop, position.top );\n\t\t\t}\n\t\t}\n\t},\n\tflip: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\touterWidth = within.width,\n\t\t\t\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = collisionPosLeft - offsetLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\tmyOffset = data.my[ 0 ] === \"left\" ?\n\t\t\t\t\t-data.elemWidth :\n\t\t\t\t\tdata.my[ 0 ] === \"right\" ?\n\t\t\t\t\t\tdata.elemWidth :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 0 ] === \"left\" ?\n\t\t\t\t\tdata.targetWidth :\n\t\t\t\t\tdata.at[ 0 ] === \"right\" ?\n\t\t\t\t\t\t-data.targetWidth :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 0 ],\n\t\t\t\tnewOverRight,\n\t\t\t\tnewOverLeft;\n\n\t\t\tif ( overLeft < 0 ) {\n\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\n\t\t\t\t\touterWidth - withinOffset;\n\t\t\t\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\n\t\t\t\t\tatOffset + offset - offsetLeft;\n\t\t\t\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.top + within.scrollTop,\n\t\t\t\touterHeight = within.height,\n\t\t\t\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = collisionPosTop - offsetTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\ttop = data.my[ 1 ] === \"top\",\n\t\t\t\tmyOffset = top ?\n\t\t\t\t\t-data.elemHeight :\n\t\t\t\t\tdata.my[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\tdata.elemHeight :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 1 ] === \"top\" ?\n\t\t\t\t\tdata.targetHeight :\n\t\t\t\t\tdata.at[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\t-data.targetHeight :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 1 ],\n\t\t\t\tnewOverTop,\n\t\t\t\tnewOverBottom;\n\t\t\tif ( overTop < 0 ) {\n\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\n\t\t\t\t\touterHeight - withinOffset;\n\t\t\t\tif ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\n\t\t\t\t\toffset - offsetTop;\n\t\t\t\tif ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tflipfit: {\n\t\tleft: function() {\n\t\t\t$.ui.position.flip.left.apply( this, arguments );\n\t\t\t$.ui.position.fit.left.apply( this, arguments );\n\t\t},\n\t\ttop: function() {\n\t\t\t$.ui.position.flip.top.apply( this, arguments );\n\t\t\t$.ui.position.fit.top.apply( this, arguments );\n\t\t}\n\t}\n};\n\n} )();\n\nreturn $.ui.position;\n\n} );\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}